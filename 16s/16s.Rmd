---
title: Cryopreservation of a soil microbiome using a Stirling Cycle approach – a genomic (16s data)
  assessment
author: Payton Yau
date: 2023-11-03
output:
  pdf_document:
    toc: true
    toc_depth: 2
    number_sections: true
  html_document:
    toc: true
    toc_depth: 2
    number_sections: true
---

## Cyropreserve CABI

Soil microbiomes are responsive to seasonal and long-term environmental factors, impacting their composition and function. This manuscript explores cryopreservation techniques using a controlled rate cooler and assesses the genomic integrity and bacterial growth of an exemplar soil sample before and after cryopreservation. The study demonstrates that the controlled rate cooler effectively preserves the DNA content of the microbiome. Two cryopreservation methods were compared with control samples, and the results indicate successful cryopreservation using metabarcoding. Enrichment with liquid medium showed similar responses between cryopreserved and non-cryopreserved soil samples, supporting the efficacy of cryopreservation. This study represents the first report of cryopreservation of soil using a Stirling cycle cooling approach, highlighting its potential for future microbiome research.

### Load the required packages

```{r install, warning=FALSE, message=FALSE}
# install.packages(c("ggplot2", "ggpubr", "dplyr", 
#                   "rstatix", "purrr", "reshape2",
#                   "UpSetR","plyr", "dplyr", "RColorBrewer"))
library("ggplot2")
library("ggpubr")
library("dplyr")
library("rstatix")
library("purrr")
library("reshape2")
library("UpSetR")
library("plyr")
library("dplyr")
library("RColorBrewer")

# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install(c("phyloseq", "DESeq2", "microbiome"))
library("phyloseq")
library("DESeq2")
library("microbiome")

# if(!requireNamespace("devtools", quietly = TRUE)){install.packages("devtools")}
# devtools::install_github("jbisanz/qiime2R") # current version is 0.99.20
library("qiime2R")

# devtools::install_github("pmartinezarbizu/pairwiseAdonis/pairwiseAdonis")
library("pairwiseAdonis")
```

### Qiime2 to Phyloseq

To work with QIIME2 outcomes in the R environment, it is beneficial to convert the data into the phyloseq object structure. This process involves importing and transforming the feature table and sample metadata, allowing for comprehensive analysis and visualisation of microbial community profiles. The phyloseq package in R provides functions to organize and manipulate the data within the phyloseq object, enabling various analyses such as diversity assessments, differential abundance testing, and taxonomic profile visualization. By converting QIIME2 outcomes to phyloseq, researchers can leverage the capabilities of R for advanced statistical analysis, integration with other omics data, and gaining deeper insights into the microbiome datasets.

```{r step 0, , warning=FALSE, message=FALSE}
# Convert qiime2 to phyloseq format
physeq <- qza_to_phyloseq(
  features = "qiime2/430_327_213_table-with-phyla-no-mitochondria-no-chloroplast.qza", # table.qza
  # tree = "inst/artifacts/2020.2_moving-pictures/rooted-tree.qza",
  taxonomy = "qiime2/430_327_213_taxonomy.qza",
  metadata = "16s-meta-data.txt"
)

physeq ## confirm the object
```

### import data and subgroup the data

Normalising the number of reads in each sample is an important step in analysing sequencing data, as it helps to remove any biases introduced by differences in sequencing depth across samples. One commonly used method for normalisation is to scale the read counts by the median sequencing depth.

```{r pressure, , warning=FALSE, message=FALSE}
## Normalise number of reads in each sample by using median sequencing depth

# Calculate the median sequencing depth
total <- median(sample_sums(physeq)) 
# Define a scaling function
standf <- function(x, t = total) round(t * (x / sum(x)))
# Normalise the sample counts using the scaling function
physeq.norm <- transform_sample_counts(physeq, standf)

# Clean up by removing objects that are no longer needed
rm(total, standf)
```

### Sub-grouping

Separate analysis is necessary for the Direct and Enriched experiments since the data contained in each subset differs and requires distinct examination.

```{r abc, warning=FALSE, message=FALSE}
## Subgroup - Direct
physeq.norm.ori <- subset_samples(physeq.norm, Comparison=="Direct") 
# Get the column names of the sample_data
colnames(sample_data(physeq.norm.ori))
# Find the index of the "Group" column
group_index <- which(colnames(sample_data(physeq.norm.ori)) == "Group")
# Rename the "Group" column to "Direct"
colnames(sample_data(physeq.norm.ori))[group_index] <- "Direct"
# Copy the column information from "Direct" to "Group"
sample_data(physeq.norm.ori)$Group <- sample_data(physeq.norm.ori)$Direct


## Subgroup - Enriched
physeq.norm.rich <- subset_samples(physeq.norm, Comparison=="Enriched") 
# Get the column names of the sample_data
colnames(sample_data(physeq.norm.rich))
# Find the index of the "Group" column
group_index <- which(colnames(sample_data(physeq.norm.rich)) == "Group")
# Rename the "Group" column to "Direct"
colnames(sample_data(physeq.norm.rich))[group_index] <- "Enriched"
# Copy the column information from "Enriched" to "Group"
sample_data(physeq.norm.rich)$Group <- sample_data(physeq.norm.rich)$Enriched


## Merge the replicate samples for each Group
physeq.norm.ori.group = merge_samples(physeq.norm.ori, "Direct") # Sum between replicate samples
sample_data(physeq.norm.ori.group)$Direct <- rownames(sample_data(physeq.norm.ori.group))

physeq.norm.rich.group = merge_samples(physeq.norm.rich, "Enriched") # Sum between replicate samples
sample_data(physeq.norm.rich.group)$Enriched <- rownames(sample_data(physeq.norm.rich.group))

# Clean up by removing objects that are no longer needed
rm(physeq.norm, group_index)
```

### Beta diversity 

Beta diversity is a measure used in ecological and microbial community studies to assess the dissimilarity of species or taxa compositions between different samples. It quantifies the variation in community structure and helps researchers understand the diversity and uniqueness of microbial communities. Various metrics, such as Bray-Curtis dissimilarity and Jaccard index, are employed to calculate beta diversity values, which can be visualized using techniques like Principal Coordinate Analysis or Non-Metric Multidimensional Scaling. Beta diversity analysis allows for comparisons of microbial communities across habitats, treatments, or environmental gradients, revealing factors influencing community variation and identifying key drivers of community structure. It provides insights into the functional and ecological significance of different microbial assemblages and their responses to environmental changes, aiding our understanding of microbial community dynamics and their roles in ecology, environmental science, and human health research.

```{r two, , warning=FALSE, message=FALSE}
## Beta diversity  - Direct
nmds.ori <- ordinate(physeq = physeq.norm.ori, method = "NMDS", distance = "bray")

Beta.ori <- plot_ordination(
  physeq = physeq.norm.ori,
  ordination = nmds.ori,
  color = "Direct",
  shape = "Direct") +
  theme_classic() + 
  geom_point(aes(color = Direct), alpha = 1, size = 4) +
  theme(text = element_text(size=18, colour = "black"), 
        axis.ticks = element_line(colour = "black", size = 1.1),
        axis.line = element_line(colour = 'black', size = 1.1),
        axis.text.x = element_text(colour = "black", angle=0, 
                                   hjust=0.5, size = 13, face="bold"),
        axis.text.y = element_text(colour = "black", angle=0, 
                                   hjust=0.5, size = 13, face="bold"),
        axis.title.y = element_text(color="black", size=20,face="bold"), 
        axis.title.x = element_text(color="black", size=20,face="bold"),
        legend.position = "bottom") + # This line moves the legend to the bottom
  stat_ellipse(geom = "polygon", type="norm", 
               alpha=0.25, aes(fill = Direct)) + # polygon, path, point
  scale_color_brewer(palette="Set2")+
  scale_fill_brewer(palette="Set2")


# pdf(file = "Beta.ori.pdf", width = 6,height = 6.1)
Beta.ori
# Close the PDF device and save the plot to a file
# dev.off()


## Beta diversity  - Enriched
nmds.rich <- ordinate(physeq = physeq.norm.rich, method = "NMDS", distance = "bray")

Beta.rich <- plot_ordination(
  physeq = physeq.norm.rich,
  ordination = nmds.rich,
  color = "Enriched",
  shape = "Enriched") +
  theme_classic() +
  geom_point(aes(color = Enriched), alpha = 1, size = 4) +
  theme(text = element_text(size=18, colour = "black"), 
        axis.ticks = element_line(colour = "black", size = 1.1),
        axis.line = element_line(colour = 'black', size = 1.1),
        axis.text.x = element_text(colour = "black", angle=0, hjust=0.5, size = 13, face="bold"),
        axis.text.y = element_text(colour = "black", angle=0, hjust=0.5, size = 13, face="bold"),
        axis.title.y = element_text(color="black", size=20,face="bold"), 
        axis.title.x = element_text(color="black", size=20,face="bold"),
        legend.position = "bottom") + # This line moves the legend to the bottom
  stat_ellipse(geom = "polygon", type="norm", alpha=0.15, aes(fill=Enriched))+ 
  scale_color_brewer(palette="Set1")+
  scale_fill_brewer(palette="Set1")


# pdf(file = "Beta.rich.pdf", width = 6,height = 6.1)
Beta.rich
# Close the PDF device and save the plot to a file
# dev.off()

# Clean up by removing objects that are no longer needed
rm(nmds.ori, Beta.ori, nmds.rich, Beta.rich)
```

### Alpha diversity

Alpha diversity is a fundamental concept in ecology and refers to the diversity or richness of species within a specific community or habitat. In the context of microbial ecology, alpha diversity represents the diversity of microorganisms within a given sample or microbiome. It provides insights into the variety and evenness of microbial species present in a particular environment. Common measures of alpha diversity include species richness, which counts the number of unique species, and evenness, which assesses the distribution of species abundances. Alpha diversity is crucial for understanding the stability, resilience, and functional potential of microbial communities. It can be influenced by various factors, including environmental conditions, host factors, and perturbations. By comparing alpha diversity across different samples or experimental groups, researchers can gain insights into the impact of factors such as disease, habitat changes, or interventions on microbial community structure.

```{r forth, , warning=FALSE, message=FALSE}
## Direct
tab = cbind(x = sample_data(physeq.norm.ori), 
            y = estimate_richness(physeq.norm.ori, measures = 'Fisher'))

stat.test <- tab %>%
  t_test(Fisher ~ x.Direct) %>%
  adjust_pvalue(method = "bonferroni") %>%
  add_significance()

alpha.ori <- ggplot(data = tab, aes(x = x.Direct, 
                                    y = Fisher, 
                                    color = x.Direct, 
                                    fill = x.Direct)) + 
  theme_classic() + 
  labs(
    x = element_blank(), 
    y = "Alpha Diversity (Fisher)") + 
  geom_point(size = 1.75) + 
  geom_boxplot(alpha = 0.5) + 
  stat_pvalue_manual(stat.test, 
                     y.position = c(1250, 1305, 1370),
                     label = "p.adj.signif",
                     face="bold", 
                     size = 6, 
                     linetype = 1,
                     tip.length = 0.02,
                     inherit.aes = FALSE) + 
  scale_y_continuous(limits=c(350, 1380), breaks = c(350, 700, 1050, 1360)) +
  theme(text = element_text(size=18, colour = "black"), 
        axis.ticks = element_line(colour = "black", size = 1.1),
        axis.line = element_line(colour = 'black', size = 1.1),
        axis.text.x = element_text(colour = "black",
                                   angle=0, 
                                   size = 13, face="bold"),
        axis.text.y = element_text(angle=0, hjust=0, colour = "black",
                                   size = 13, face="bold"),
        axis.title.y = element_text(color="black", size=15,face="bold"),
        legend.position = "none") +
  scale_color_brewer(palette="Set2")+
  scale_fill_brewer(palette="Set2")

# pdf(file = "alpha.ori.pdf", width = 6, height = 5)
alpha.ori
# Close the PDF device and save the plot to a file
# dev.off()



## Enriched
tab1 = cbind(x = sample_data(physeq.norm.rich), 
            y = estimate_richness(physeq.norm.rich, measures = 'Fisher'))

stat.test1 <- tab1 %>%
  t_test(Fisher ~ x.Enriched) %>%
  adjust_pvalue(method = "bonferroni") %>%
  add_significance()

alpha.rich <- ggplot(data = tab1, aes(x = x.Enriched, 
                                      y = Fisher, 
                                      color = x.Enriched, 
                                      fill = x.Enriched)) + 
  theme_classic() + 
  labs(
    x = element_blank(), 
    y = "Alpha Diversity (Fisher)") + 
  geom_point(size = 1.75) + 
  geom_boxplot(alpha = 0.5) + 
  stat_pvalue_manual(stat.test1, 
                     y.position = c(70, 74.5, 80),
                     label = "p.adj.signif",
                     face="bold", 
                     size = 6, 
                     linetype = 1,
                     tip.length = 0.02,
                     inherit.aes = FALSE) + 
  scale_y_continuous(limits=c(0, 80), breaks = c(0, 20, 40, 60, 80)) +
  theme(text = element_text(size=18, colour = "black"), 
        axis.ticks = element_line(colour = "black", size = 1.1),
        axis.line = element_line(colour = 'black', size = 1.1),
        axis.text.x = element_text(colour = "black",
                                   angle=0, 
                                   size = 13, face="bold"),
        axis.text.y = element_text(angle=0, hjust=0, colour = "black",
                                   size = 13, face="bold"),
        axis.title.y = element_text(color="black", size=15,face="bold"),
        legend.position = "none") +
  scale_color_brewer(palette="Set1")+
  scale_fill_brewer(palette="Set1")

# pdf(file = "alpha.rich.pdf", width = 6, height = 5)
alpha.rich
# Close the PDF device and save the plot to a file
# dev.off()

# Clean up by removing objects that are no longer needed
rm(tab, stat.test, alpha.ori, tab1, stat.test1, alpha.rich)
```

#### Determine the count of taxa within each level and group

The purpose of this process is to visualise the distribution of the number of matched abundance across different groups and to identify any patterns in the distribution of the processed abundance within individual group.


```{r physeq.norm.ori.group, warning=FALSE, message=FALSE}
# Create an empty list to store genus-level abundance data for each taxonomic level
gentab_levels <- list()

# Set observation threshold
observationThreshold <- 1

# Define the taxonomic levels
genus_levels <- c("Kingdom", "Phylum", "Class", "Order", 
                  "Family", "Genus", "Species")

# loop through all the taxonomic levels
for (level in genus_levels) {
  
  # create a factor variable for each level
  genfac <- factor(tax_table(physeq.norm.ori.group)[, level])
  
  # calculate the abundance of each level within each sample
  gentab <- apply(otu_table(physeq.norm.ori.group), MARGIN = 1, function(x) {
    tapply(x, INDEX = genfac, FUN = sum, na.rm = TRUE, simplify = TRUE)
  })
  
  # calculate the number of samples in which each level is observed above the threshold
  level_counts <- apply(gentab > observationThreshold, 2, sum)
  
  # create a data frame of level counts with names as row names
  BB <- as.data.frame(level_counts)
  BB$name <- row.names(BB)
  
  # add the data frame to the gentab_levels list
  gentab_levels[[level]] <- BB
}

# Combine all level counts data frames into one data frame
B2 <- gentab_levels %>% purrr::reduce(dplyr::full_join, by = "name")

# Set row names and column names
rownames(B2) <- B2$name
B2$name <- NULL
colnames(B2)[1:7] <- genus_levels
B2$name <- rownames(B2)
B2$Species <- NULL

data_long <- melt(B2, id.vars = "name", 
                  variable.name = "Dataset", 
                  value.name = "Count")

colnames(data_long) = c("Direct","Taxonomic.Level","Count")


tax.ori <- ggplot(data_long, aes(x = Taxonomic.Level, 
                                 y = Count, 
                                 color = Direct, 
                                 group = Direct)) +
  geom_line(size = 2) +
  geom_point(size = 4) +
  labs(x = "Taxonomic Level", y = "Count", color = "Direct") +
  theme_classic() + 
  theme(
    text = element_text(size = 19, colour = "black"), 
    axis.ticks = element_line(colour = "black", size = 1.1),
    axis.line = element_line(colour = 'black', size = 1.1),
    axis.text.x = element_text(colour = "black", angle = 0, hjust = 0.5, size = 13, face = "bold"),
    axis.text.y = element_text(colour = "black", angle = 0, hjust = 0.5, size = 13, face = "bold"),
    axis.title.y = element_text(color = "black", size = 14, face = "bold"), 
    axis.title.x = element_text(color = "black", size = 14, face = "bold"),
    legend.position = "bottom") + # This line moves the legend to the bottom
  scale_color_brewer(palette="Set2") +
  scale_x_discrete(guide = guide_axis(n.dodge=2)) +
  scale_y_continuous(breaks=seq(0,600,by=100))


# pdf(file = "tax.ori.pdf", width = 6, height = 6.1)
tax.ori
# Close the PDF device and save the plot to a file
# dev.off()

# Clean up by removing unnecessary objects
rm(gentab_levels, genus_levels, observationThreshold, 
   BB, B2, data_long, gentab, tax.ori, genfac, level, level_counts)

```

```{r physeq.norm.rich.group, warning=FALSE, message=FALSE}
# Create an empty list to store genus-level abundance data for each taxonomic level
gentab_levels <- list()

# Set observation threshold
observationThreshold <- 1

# Define the taxonomic levels
genus_levels <- c("Kingdom", "Phylum", "Class", "Order", 
                  "Family", "Genus", "Species")

# loop through all the taxonomic levels
for (level in genus_levels) {
  
  # create a factor variable for each level
  genfac <- factor(tax_table(physeq.norm.rich.group)[, level])
  
  # calculate the abundance of each genus within each sample
  gentab <- apply(otu_table(physeq.norm.rich.group), MARGIN = 1, function(x) {
    tapply(x, INDEX = genfac, FUN = sum, na.rm = TRUE, simplify = TRUE)
  })
  
  # calculate the number of samples in which each genus is observed above the threshold
  level_counts <- apply(gentab > observationThreshold, 2, sum)
  
  # create a data frame of level counts with genus names as row names
  BB <- as.data.frame(level_counts)
  BB$name <- row.names(BB)
  
  # add the data frame to the gentab_levels list
  gentab_levels[[level]] <- BB
}

# Combine all level counts data frames into one data frame
B2 <- gentab_levels %>% purrr::reduce(dplyr::full_join, by = "name")

# Set row names and column names
rownames(B2) <- B2$name
B2$name <- NULL
colnames(B2)[1:7] <- genus_levels
B2$Species <- NULL
B2$name <- rownames(B2)

data_long <- melt(B2, id.vars = "name", variable.name = "Dataset", value.name = "Count")
colnames(data_long) = c("Enriched","Taxonomic.Level","Count")


tax.rich <- ggplot(data_long, aes(x = Taxonomic.Level, 
                                  y = Count, 
                                  color = Enriched, 
                                  group = Enriched)) +
  geom_line(size = 2) +
  geom_point(size = 4) +
  labs(x = "Taxonomic Level", y = "Count", color = "Enriched") +
  theme_classic() + 
  theme(
    text = element_text(size = 19, colour = "black"), 
    axis.ticks = element_line(colour = "black", size = 1.1),
    axis.line = element_line(colour = 'black', size = 1.1),
    axis.text.x = element_text(colour = "black", angle = 0, hjust = 0.5, size = 13, face = "bold"),
    axis.text.y = element_text(colour = "black", angle = 0, hjust = 0.5, size = 13, face = "bold"),
    axis.title.y = element_text(color = "black", size = 14, face = "bold"), 
    axis.title.x = element_text(color = "black", size = 14, face = "bold"),
    legend.position = "bottom") + # This line moves the legend to the bottom
    scale_color_brewer(palette="Set1") +
  scale_x_discrete(guide = guide_axis(n.dodge=2)) +
  scale_y_continuous(breaks=seq(0,200,by=50))

# pdf(file = "tax.rich.pdf", width = 6, height = 6.1)
tax.rich
# Close the PDF device and save the plot to a file
# dev.off()

# Clean up by removing unnecessary objects
rm(gentab_levels, genus_levels, observationThreshold, 
   BB, B2, data_long, gentab, tax.rich, genfac, level, level_counts)

```

### Upset plot using UpsetR

Venn diagrams are commonly used for visualizing sets, but they can become complex with more than five sets. UpSet graphs, on the other hand, offer a more efficient way to display intersections and complements, especially for larger or multiple datasets. They provide a more intuitive and informative data representation.

```{r UpSetR1, warning=FALSE, message=FALSE}
# Aggregate taxa at the genus level
B <- aggregate_taxa(physeq.norm.ori.group, "Genus", verbose = TRUE)
# Remove undesired genera
# B2 <- subset_taxa(B, !get("Genus") %in% c("uncultured", "Unknown"))

# Remove unwanted taxon names
taxa_to_remove <- c("uncultured", "Unknown")
B2 <- subset_taxa(B, !get("Genus") %in% taxa_to_remove)

# Extract relevant data from the phyloseq object
sample_data <- sample_data(B2)
otu_table <- otu_table(B2)
abundance <- as.vector(otu_table)

# Create a tibble with the extracted data
D <- tibble(
  Sample = rep(sample_data$Direct, each = nrow(otu_table)),
  ASV = rep(rownames(otu_table), times = ncol(otu_table)),
  Abundance = abundance
) %>%
  group_by(Sample) %>%
  mutate(rank = rank(plyr::desc(Abundance))) %>%
   filter(Abundance > 0) %>%
  ungroup() %>%
  select(Sample, Abundance, ASV)

# Remove the Abundance column
D$Abundance <- NULL

# Rename the second column to "ASV"
names(D)[2] <- "ASV"
names(D)[1] <- "Direct"

# Convert data from long to wide format
E <- dcast(D, ASV ~ Direct)

# Define a binary function
binary_fun <- function(x) {
  x[is.na(x)] <- 0
  ifelse(x > 0, 1, 0)
}

col = c("#FC8D62", "#8DA0CB","#66C2A5")

# Apply the binary function to columns 2 to 4
temp_df <- apply(E[2:4], 2, binary_fun)
temp_df <- as.data.frame(temp_df)

# Create an UpSet plot
UpSet.Ori <- upset(temp_df, 
                    sets = colnames(temp_df), 
                    sets.bar.color = (col),
                    order.by = "freq", 
                    empty.intersections = "on",
                    mainbar.y.label = "Counts by Pattern of Conditions", 
                    sets.x.label = "Counts by Condition",
                    matrix.color="blue", 
                    mb.ratio = c(0.65, 0.35),
                    point.size= 2.75,
                    line.size = 1.25, 
                    text.scale = 1.5
)


# Open a new PDF graphics device
# pdf(file = "UpSet.Ori.pdf", width=6.5,height=4.5)

# Print the UpSet plot
print(UpSet.Ori)

# Close the PDF device and save the plot to a file
# dev.off()  
```


```{r UpSetR2, warning=FALSE, message=FALSE}
# Aggregate taxa at the genus level
B <- aggregate_taxa(physeq.norm.rich.group, "Genus", verbose = TRUE)
# Remove undesired genera
# B2 <- subset_taxa(B, !get("Genus") %in% c("uncultured", "Unknown"))

# Remove unwanted taxon names
taxa_to_remove <- c("uncultured", "Unknown")
B2 <- subset_taxa(B, !get("Genus") %in% taxa_to_remove)

# Extract relevant data from the phyloseq object
sample_data <- sample_data(B2)
otu_table <- otu_table(B2)
abundance <- as.vector(otu_table)

# Create a tibble with the extracted data
D <- tibble(
  Sample = rep(sample_data$Enriched, each = nrow(otu_table)),
  ASV = rep(rownames(otu_table), times = ncol(otu_table)),
  Abundance = abundance
) %>%
  group_by(Sample) %>%
  mutate(rank = rank(plyr::desc(Abundance))) %>%
   filter(Abundance > 0) %>%
  ungroup() %>%
  select(Sample, Abundance, ASV)

# Remove the Abundance column
D$Abundance <- NULL

# Rename the second column to "ASV"
names(D)[2] <- "ASV"
names(D)[1] <- "Direct"

# Convert data from long to wide format
E <- dcast(D, ASV ~ Direct)

# Define a binary function
binary_fun <- function(x) {
  x[is.na(x)] <- 0
  ifelse(x > 0, 1, 0)
}

col = brewer.pal(n = 3, name = "Set1")

# Apply the binary function to columns 2 to 4
temp_df <- apply(E[2:4], 2, binary_fun)
temp_df <- as.data.frame(temp_df)

# Create an UpSet plot
upset.Rich <- upset(temp_df, 
                    sets = colnames(temp_df), 
                    sets.bar.color = (col),
                    order.by = "freq", 
                    empty.intersections = "on",
                    mainbar.y.label = "Counts by Pattern of Conditions", 
                    sets.x.label = "Counts by Condition",
                    matrix.color="blue", 
                    mb.ratio = c(0.65, 0.35),
                    point.size= 2.75,
                    line.size = 1.25, 
                    text.scale = 1.5
)


# Open a new PDF graphics device
# pdf(file = "upset.Rich.pdf", width=6.5,height=4.5)

# Print the UpSet plot
print(upset.Rich)

# Close the PDF device and save the plot to a file
# dev.off()  
```
### Pairwise comparison using PERMANOVA

Pairwise PERMANOVA (Permutational Multivariate Analysis of Variance) is a statistical method used in microbial community studies to examine differences between groups or treatments. It assesses the dissimilarity between samples, allowing for the comparison of multivariate data. This approach is useful to focus on specific group comparisons rather than comparing all groups simultaneously. It enables the investigation of the effects of specific treatments on microbial communities, helping to determine if there are significant differences in community composition between selected groups. By considering variation within and between groups, pairwise PERMANOVA offers a robust statistical assessment of dissimilarity, providing insights into community structure differences.

```{r fifth, echo=FALSE}
## enriched data
metdat.rich = as.data.frame(as.matrix(physeq.norm.rich@sam_data))
dat.rich = as.data.frame(t(as.data.frame(physeq.norm.rich@otu_table)))
pairwise.adonis(dat.rich, metdat.rich$Group, sim.function = "vegdist",
                sim.method = "bray", p.adjust.m = "bonferroni",
                reduce = NULL, perm = 100000)

## Direct data
metdat.ori = as.data.frame(as.matrix(physeq.norm.ori@sam_data))
dat.ori = as.data.frame(t(as.data.frame(physeq.norm.ori@otu_table)))
pairwise.adonis(dat.ori, metdat.ori$Group, sim.function = "vegdist",
                sim.method = "bray", p.adjust.m = "bonferroni",
                reduce = NULL, perm = 100000)

# Clean up by removing objects that are no longer needed
rm(metdat.rich, dat.rich, metdat.ori, dat.ori)
```

### Top 10 at family level

In microbiome analysis, identifying the top 10 bacteria in the top 10 family level and their corresponding percentages provides a snapshot of the microbial community’s composition. 

```{r TOP10, warning=FALSE, message=FALSE}
# Merge reads by groups (Direct)
physeq.ori <- subset_samples(physeq, Comparison=="Direct") 
AyBCode <- merge_samples(physeq.ori, "Group", fun = sum)

## Normalised number of reads in percentage
standf = function(x) x / sum(x) * 100
AyBCode.percent = transform_sample_counts(AyBCode, standf)

top10otus = names(sort(taxa_sums(AyBCode.percent), TRUE)[1:26])
taxtab10 = cbind(tax_table(AyBCode.percent), Family = NA)
taxtab10[top10otus, "Family"] <- as(tax_table(AyBCode.percent)[top10otus, "Family"],"character")
tax_table(AyBCode.percent) <- tax_table(taxtab10)

top10plot = prune_taxa(top10otus, AyBCode.percent)

top10.ori <- plot_bar(top10plot, fill = "Family") + coord_flip() + 
  ylab("Taxa Matched with Silva138 (%)") + ylim(0, 20) + 
  theme_classic() + 
  theme(text = element_text(size=14, colour = "black"), 
        axis.ticks = element_line(colour = "black", size = 1.1),
        axis.line = element_line(colour = 'black', size = 1.1),
        axis.text.x = element_text(colour = "black", angle=0, size = 11, face="bold"),
        axis.text.y = element_text(angle=0, hjust=0, colour = "black", size = 11, face="bold"),
        axis.title.y = element_text(color="black", size=12,face="bold"),
        axis.title.x = element_text(color="black", size=12,face="bold"),
        legend.position = "right") +
  scale_color_brewer(palette="Spectral")+
  scale_fill_brewer(palette="Spectral") +
  xlab("") # This line removes the x-axis label


# pdf(file = "top10.ori.pdf", width = 6.75, height = 5)
top10.ori
# Close the PDF device and save the plot to a file
# dev.off()

# Merge reads by groups (Enriched)
physeq.rich <- subset_samples(physeq, Comparison=="Enriched") 
AyBCode <- merge_samples(physeq.rich, "Group", fun = sum)

## Normalised number of reads in percentage
standf = function(x) x / sum(x) * 100
AyBCode.percent = transform_sample_counts(AyBCode, standf)

top10otus = names(sort(taxa_sums(AyBCode.percent), TRUE)[1:23])
taxtab10 = cbind(tax_table(AyBCode.percent), Family = NA)
taxtab10[top10otus, "Family"] <- as(tax_table(AyBCode.percent)[top10otus, "Family"],"character")
tax_table(AyBCode.percent) <- tax_table(taxtab10)

top10plot = prune_taxa(top10otus, AyBCode.percent)

top10.rich <- plot_bar(top10plot, fill = "Family") + coord_flip() + 
  ylab("Taxa Matched with Silva138 (%)") + ylim(0, 100) + 
  theme_classic() + 
  theme(text = element_text(size=14, colour = "black"), 
        axis.ticks = element_line(colour = "black", size = 1.1),
        axis.line = element_line(colour = 'black', size = 1.1),
        axis.text.x = element_text(colour = "black", angle=0, size = 11, face="bold"),
        axis.text.y = element_text(angle=0, hjust=0, colour = "black", size = 11, face="bold"),
        axis.title.y = element_text(color="black", size=12,face="bold"),
        axis.title.x = element_text(color="black", size=12,face="bold"),
        legend.position = "right") +
  scale_color_brewer(palette="Spectral")+
  scale_fill_brewer(palette="Spectral") +
  xlab("") # This line removes the x-axis label

# pdf(file = "top10.rich.pdf", width = 6.75, height = 5)
top10.rich
# Close the PDF device and save the plot to a file
# dev.off()

# Clean up by removing objects that are no longer needed
rm(physeq.ori, physeq.rich, AyBCode, 
   standf, AyBCode.percent, top10otus, 
   taxtab10, top10plot, top10.ori, top10.rich)
```

```{r sessionInfo, warning=FALSE, message=FALSE}
sessionInfo()
```